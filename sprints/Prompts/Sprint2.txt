Executive SummaryModern voicebots are at the vanguard of frictionless, natural conversation in banking, contact centers, and beyond. With the maturation of high-accuracy STT like OpenAI’s Whisper, powerful open or hosted LLMs such as Mistral, and fast, multi-lingual TTS (e.g., Kokoro), the technical barrier for DIY enterprise voicebot stacks has lowered dramatically. Yet, unlocking true business value demands much more than simply gluing STT, LLM, and TTS modules together. Orchestration, CLI tooling for devops, analytics for measurement, domain logic (e.g., loan calculation), compliance, semantic cache optimization, and LoRA adapter training are each crucial for an enterprise-grade, scalable system.This comprehensive report maps out the development and delivery of a Python-based, modular voicebot orchestration system across six sprints, each focusing on a key architectural or domain goal. For each sprint, we explain component roles, selected tech, CLI command examples, analytics strategies, and robust testing plans. Special attention is paid to bank-domain logic, compliance, microservice/package architecture, and performance optimizations, ensuring that the resultant solution is both scalable and compliant with water-tight governance. We conclude with a full tech stack and pip package summary.Tech Stack & Pip Package TableComponentTechnology / LibraryPip PackagesSpeech-to-Text (STT)Whisper (OpenAI/HF)openai-whisper, torchaudio, transformers, ffmpeg-pythonLarge Language Model (LLM)Mistral (API or hosted)mistral-ai, llm-mistral, langchain-mistralaiText-to-Speech (TTS)Kokoro (KPipeline)kokoro, misaki[en], espeak-ngCLI ToolingPython CLIstyper, click, rich, argparse, chainlitOrchestration/MicroservicesFastAPI, websocketsfastapi, websockets, aiohttp, python-dotenvAnalytics & MonitoringPrometheus, Grafana, OpenTelemetryprometheus-client, opentelemetry-api, pandas, matplotlibSemantic CacheFaiss, Sentence Transformersfaiss-cpu, sentence-transformers, redisAdapter TrainingPyTorch, peft, bitsandbytestorch, peft, bitsandbytes, transformersPackage ManagementPoetry, PyInstaller, Dockerpoetry, pyinstaller, dockerData Persistence/CacheRedis, sqliteredis, sqlite3Testing/CIPytest, Botium, Sipfrontpytest, botium-core, sipfront-apiDomain Logic (Banking)Custom Pythonnumpy, pandasAll commands assume Python 3.10+ and Linux/macOS.

You are a Python engineer tasked with Sprint 2 of our voice-bot orchestration project. Before you start, please review Sprint 1’s deliverables (STT integration, basic LLM bridge, TTS output) and let me know if any core tasks or edge cases were missed.
Sprint 2: CLI Tooling, Session Management, and Pipeline OrchestrationTasks:- Build a CLI interface (subcommands: monitor-session, orchestrator-log, replay-session, cache-manager, adapter-control).- Implement per-call session state persistence (in-memory prototype).- Add structured logging and event tracing for each pipeline component.- Expose diagnostics and replay capabilities via the CLI.- Integrate with Chainlit for browser-based scenario testing.
Python Code Generation Restrictions (Prompt Template)Environment & Version Constraints• Use Python 3.11 only.  • Only import from standard library, plus pandas, numpy, requests.  • No OS-level deps, apt-get, or compilation steps.
Security & Safety• Do not delete/modify files outside allowed paths (avoid os.remove, shutil.rmtree).  • Do not make network calls unless explicitly instructed.  • Do not execute shell commands (os.system, subprocess) with untrusted input.  • No hardcoded secrets.  • Do not use eval() or exec().
Performance & Efficiency• Avoid loading files >1 GB entirely into memory.  • Avoid O(n²) algorithms or deep recursion; prefer vectorized numpy/pandas.  • Limit recursion depth.  
Code Style & Readability• Follow PEP 8: snake_case, UpperCase constants, 4-space indent.  • Include type hints for all functions/methods.  • Add docstrings for public APIs.  • Add short comments for key logic.  • No unused imports or dead code.
Functional Restrictions• Functions must return consistent types.  • Avoid globals; prefer side-effect-free functions.  • No interactive prompts (input(), getpass()).  • Validate inputs; raise ValueError or appropriate exceptions.  • Prefer idempotent functions.
Testing & Validation• Include simple pytest-style asserts.  • Cover edge cases (empty input, None).  • Test exception paths.  • Do not assume file paths unless instructed.
INSTRUCTIONS1. Generate a full Python module named voicebot_cli.py implementing the CLI via typer or click.  2. Stub out each subcommand with proper type hints, docstrings, and structured logging via loguru.  3. Show how session state is stored in a dict and serialized to JSON.  4. Add at least three assert-based tests in a separate test_voicebot_cli.py.  5. At the top of your answer, briefly note any missing items from Sprint 1.  6. Do not include any explanations—only code, imports, and brief comments where required.
Sample seed you can expand on:
```python#!/usr/bin/env python3# voicebot_cli.py
from typing import Optional, Dictimport jsonimport typerfrom loguru import logger
app = typer.Typer()session_store: Dict[str, dict] = {}
def save_session(session_id: str) -> None:    """    Persist session state to disk as JSON.    """    with open(f"./sessions/{session_id}.json", "w", encoding="utf-8") as f:        json.dump(session_store[session_id], f)
@app.command()def monitor_session(session_id: str, tail: bool = False) -> None:    """    Live-tail state transitions for the given session.    """    state = session_store.get(session_id)    if not state:        raise typer.BadParameter(f"Session {session_id!r} not found")    logger.info(f"Monitoring session {session_id}: {state}")    # TODO: implement live tail
if __name__ == "__main__":    app()